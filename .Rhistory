runApp('surfdrive/Shiny-project/PlotTwist')
runApp('surfdrive/Shiny-project/PlotTwist')
runApp('surfdrive/Shiny-project/PlotTwist')
shiny::runApp('surfdrive/Shiny-project/PlotsOfData')
shiny::runApp('surfdrive/Shiny-project/PlotsOfData')
shiny::runApp('surfdrive/Shiny-project/PlotsOfData')
runApp('surfdrive/Shiny-project/PlotsOfData')
runApp('surfdrive/Shiny-project/PlotsOfData')
runApp('surfdrive/Shiny-project/PlotsOfData')
runApp('surfdrive/Shiny-project/PlotsOfData')
runApp('surfdrive/Shiny-project/PlotsOfData')
runApp('surfdrive/Shiny-project/PlotsOfData')
runApp('surfdrive/Shiny-project/PlotsOfData')
runApp('surfdrive/Shiny-project/PlotsOfData')
shiny::runApp('surfdrive/Shiny-project/PlotTwist')
runApp('surfdrive/Shiny-project/PlotTwist')
runApp('surfdrive/Shiny-project/PlotTwist')
runApp('surfdrive/Shiny-project/PlotTwist')
runApp('surfdrive/Shiny-project/PlotTwist')
runApp('surfdrive/Shiny-project/PlotTwist')
runApp('surfdrive/Shiny-project/PlotTwist')
shiny::runApp('surfdrive/Shiny-project/PlotsOfData')
runApp('surfdrive/Shiny-project/PlotTwist')
?dist
?t
x <- matrix(rnorm(100), nrow = 5)
ordered_list <- reactive({
klaas <-  df_binned()
if(input$ordered == "max_int") {
reordered_list <- reorder(klaas$unique_id, klaas$Value, max, na.rm = TRUE)
} else if (input$ordered == "none") {
reordered_list <- factor(klaas$unique_id, levels=unique(klaas$unique_id))
} else if (input$ordered == "int_int") {
reordered_list <- reorder(klaas$unique_id, klaas$Value, sum, na.rm = TRUE)
}  else if (input$ordered == "amplitude") {
#Determine a ranking based on amplitude = max-min
df_rank <- klaas %>% group_by(unique_id) %>% summarise(amplitude=max(Value)-min(Value)) %>% mutate(rank=percent_rank(amplitude))
reordered_list <- reorder(df_rank$unique_id, df_rank$rank)
} else if (input$ordered == "hc") {
#Convert to wide format
df_wide <- klaas %>% select(unique_id, Value,Time)  %>% spread(key=unique_id, value=Value)
#Remove Time info
df_wide <- df_wide %>% select(-Time)
#hierarchical clustering
hc <- hclust(dist(t(df_wide)))
#Column order from clustering
col.order <- hc$order
#Reorder the dataframe dat according to the column order determined by clustering
df_clustered <- df_wide[, col.order]
#Get the ordered column names from the clustered dataframe
reordered_list <- colnames(df_clustered)
observe({ print(reordered_list) })
}
ordered_list <- levels(reordered_list)
observe({ print(ordered_list) })
return(ordered_list)
})
x
dist(x, diag = TRUE)
dist(x, upper = TRUE)
x
hclust(dist(x), method = "ward.D2")
dist(x, method = "manhattan")
dist(x, method = "euclidean")
dist(x, method = "canberra")
hclust(dist(x), method = "ward.D2")
plot(hclust(dist(x), method = "ward.D2"))
plot(hclust(dist(x)))
plot(hclust(dist(x, method = "manhattan")))
plot(hclust(dist(x, method = "canberra")))
hclust(dist(x, method = "canberra"))$order
?cutree
hc <- hclust(dist(x, method = "canberra"))
cutree(hc, k = 1:3)
?dtw
runApp('surfdrive/Shiny-project/PlotsOfData')
runApp('surfdrive/Shiny-project/PlotsOfData')
runApp('surfdrive/Shiny-project/PlotsOfData')
runApp('surfdrive/Shiny-project/PlotsOfData')
?s.cl.diss
s.cl.diss
?dist
shiny::runApp('surfdrive/Shiny-project/PlotsOfData')
shiny::runApp('surfdrive/Shiny-project/PlotTwist')
setwd("~/surfdrive/R-project/Time-series-clustering")
require("ggplot2")
require("tidyr")
require("dplyr")
require("magrittr")
df1 <- read.csv("Fig3_Rac_S1P.csv")
#Get all the columns with data (without time axis)
dat <- df1[,2:31]
#Perform cluster analysis on the data
hc <- hclust(dist(t(dat)))
#Uncomment to plot the dendogram
#plot(as.dendrogram(hc),horiz=T)
#determine column order that came out of cluster analysis (http://swarchal.github.io/pages/2015/11/25/heatmap-ggplot/)
col.order <- hc$order
#Reorder the dataframe dat according to the column order determined by clustering
dat_new <- dat[, col.order]
#Add the Time data back to the dataframe
dat_new$Time <- df1$Time
#Convert to tidy format
df_tidy <- gather(dat_new, Cell, Ratio, -Time)
#Use the column order from the dataframe for plotting
df_tidy$Cell <- factor(df_tidy$Cell, levels = df_tidy$Cell)
#Define the plot
p <- ggplot(df_tidy, aes(x=Time, y=Cell)) + geom_tile(aes(fill=Ratio)) +  scale_fill_gradient(low="darkblue", high="yellow")
#Basic format
p <- p + theme_light(base_size = 16)
#Remove gridlines
p <- p + theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
#Remove lines for axis
p <- p+ theme(panel.border = element_blank(),
axis.ticks = element_line(colour = "grey20"))
#Plot the heatmap
p
require("ggplot2")
require("tidyr")
require("dplyr")
require("magrittr")
df1 <- read.csv("Fig3_Rac_S1P.csv")
dat <- df1[,2:31]
#Perform cluster analysis on the data
hc <- hclust(dist(t(dat)))
plot(as.dendrogram(hc),horiz=T)
col.order <- hc$order
hc$order
grp <- cutree(hc, k = 3)
plot(hc, cex = 0.6)
rect.hclust(hc, k = 3, border = 2:5)
grp
plot(as.dendrogram(hc),horiz=T)
df_tidy$groups <- grp
df1
col.order
grp
class(grp)
dat_new <- dat[, col.order]
dat_new$Time <- df1$Time
df_tidy <- gather(dat_new, Cell, Ratio, -Time)
View(df1)
df1 <- read.csv("Fig3_Rac_S1P_30.csv")
#Get all the columns with data (without time axis)
dat <- df1[,2:31]
#Perform cluster analysis on the data
hc <- hclust(dist(t(dat)))
#Uncomment to plot the dendogram
#plot(as.dendrogram(hc),horiz=T)
#determine column order that came out of cluster analysis (http://swarchal.github.io/pages/2015/11/25/heatmap-ggplot/)
col.order <- hc$order
#Define groups from a cut-off k
group <- cutree(hc, k = 3)
#Reorder the dataframe dat according to the column order determined by clustering
dat_new <- dat[, col.order]
#Add the Time data back to the dataframe
dat_new$Time <- df1$Time
#Convert to tidy format
df_tidy <- gather(dat_new, Cell, Ratio, -Time)
df_tidy
col.order
group
group[1]
group[2]
group[2,1]
as.data.frame(group)
group <- as.data.frame(group)
View(group)
View(df1)
View(df_tidy)
group$group
group
colnames(group)
?cutree
View(dat)
View(dat_new)
View(df_tidy)
View(df1)
View(group)
View(hc)
View(group)
group <- cutree(hc, k = (2,4))
group <- cutree(hc, k = c(2,4))
group
hc$labels
group <- cutree(hc, k = 3)
as_tibble(group)
group
dim(group)
as.matrix(group)
rownames(group)
rownames(as.matrix(group))
rownames(as.data.frame(group))
dat_new <- dat[, col.order]
View(dat_new)
dat_new$Time <- df1$Time
df_tidy <- gather(dat_new, Cell, Ratio, -Time)
View(df_tidy)
df_group <- as.data.frame(group)
df_group$Cell <- rownames(df_group)
df_group
group <- cutree(hc, k = 3)
df_group <- as.data.frame(group)
df_group <- as.data.frame(group)
df_group$Cell <- rownames(df_group)
View(df_group)
left_join(df_tidy,df_group, by="Cell")
tail(left_join(df_tidy,df_group, by="Cell"))
df_tidy <- df_tidy %>% left_join(df_group, by="Cell")
View(df_tidy)
col.order <- hc$order
#Define groups from a cut-off k
group <- cutree(hc, k = 3)
df_group <- as.data.frame(group)
df_group <- as.data.frame(group)
df_group$Cell <- rownames(df_group)
#Reorder the dataframe dat according to the column order determined by clustering
dat_new <- dat[, col.order]
#Add the Time data back to the dataframe
dat_new$Time <- df1$Time
#Convert to tidy format
df_tidy <- gather(dat_new, Cell, Ratio, -Time)
df_tidy <- df_tidy %>% left_join(df_group, by="Cell")
View(df_tidy)
View(df_group)
View(df_tidy)
p <- ggplot(df_tidy, aes(x=Time, y=Cell)) + geom_tile(aes(fill=Ratio)) +  scale_fill_gradient(low="darkblue", high="yellow")
p <- p + theme_light(base_size = 16)
#Remove gridlines
p <- p + theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
#Remove lines for axis
p <- p+ theme(panel.border = element_blank(),
axis.ticks = element_line(colour = "grey20"))
#Plot the heatmap
p
?facet_wrap
?tally
table(group)
p + facet_wrap(~group)
p + facet_grid(~group)
p + facet_wrap(~.,group)
p + facet_grid(~group, scale="free_y")
p + facet_grid(~group, scale="free_y", nrow=3)
p + facet_grid(~group, scale="free_y")
p + facet_grid(~group, scales = "free", space = "free_y")
p + facet_grid(~group, scales = "free", space = "free_y", ncol=1)
p + facet_grid(~group, scales = "free", space = "free_y", nrow=1)
p + facet_grid(~group, scales = "free", space = "free_y")
p + facet_grid(~group, ncol=1,scales = "free", space = "free_y")
p + facet_wrap(~group, ncol=1,scales = "free", space = "free_y")
p + facet_wrap(~group, ncol=1,scales = "free")
p + facet_wrap(~group, nrow =1,scales = "free")
p + facet_wrap(~group, ncol =1,scales = "free")
p + facet_wrap(~group, scales = "free")
p + facet_wrap(~group)
p + facet_wrap(~group, scales = free_y)
p + facet_wrap(~group, scales = "free_y"")
p + facet_wrap(~group, scales = "free_y")
dat
t(dat)
dst <- dist(dat)
dst <- data.matrix(dst)
dim <- ncol(dst)
image(1:dim, 1:dim, dst, axes = FALSE, xlab="", ylab="")
dim
dst <- data.matrix(dist(dat))
dist(dat)
dim(dst)
dst <- dist(dat)
dim <- ncol(dst)
image(1:dim, 1:dim, dst, axes = FALSE, xlab="", ylab="")
image(1:121, 1:121, dst, axes = FALSE, xlab="", ylab="")
image(1:121, 1:121, as.matrx(dst), axes = FALSE, xlab="", ylab="")
image(1:121, 1:121, as.matrix(dst), axes = FALSE, xlab="", ylab="")
image(1:12, 1:12, as.matrix(dst), axes = FALSE, xlab="", ylab="")
image(1:121, 1:121, as.matrix(dst), axes = FALSE, xlab="", ylab="")
image(1:ncol(dst), 1:ncol(dst), as.matrix(dst), axes = FALSE, xlab="", ylab="")
dst <- dist(dat)
ncol(dst)
as.matrix(dst)
ncol(as.matrix(dst))
image(1:ncol(dst_matrix), 1:ncol(dst_matrix), dst_matrix, axes = FALSE, xlab="", ylab="")
dst_matrix <- as.matrix(dst)
image(1:ncol(dst_matrix), 1:ncol(dst_matrix), dst_matrix, axes = FALSE, xlab="", ylab="")
?image
?hclust
hc <- hclust(dst, method="ward.D2")
hc <- hclust(dst, method="ward.D2")
col.order <- hc$order
#Define groups from a cut-off k
group <- cutree(hc, k = 3)
df_group <- as.data.frame(group)
df_group <- as.data.frame(group)
df_group$Cell <- rownames(df_group)
#Reorder the dataframe dat according to the column order determined by clustering
dat_new <- dat[, col.order]
#Add the Time data back to the dataframe
dat_new$Time <- df1$Time
#Convert to tidy format
df_tidy <- gather(dat_new, Cell, Ratio, -Time)
#Add group number
df_tidy <- df_tidy %>% left_join(df_group, by="Cell")
#Use the column order from the dataframe for plotting
df_tidy$Cell <- factor(df_tidy$Cell, levels = df_tidy$Cell)
#Define the plot
p <- ggplot(df_tidy, aes(x=Time, y=Cell)) + geom_tile(aes(fill=Ratio)) +  scale_fill_gradient(low="darkblue", high="yellow")
#Basic format
p <- p + theme_light(base_size = 16)
#Remove gridlines
p <- p + theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
#Remove lines for axis
p <- p+ theme(panel.border = element_blank(),
axis.ticks = element_line(colour = "grey20"))
#Plot the heatmap
p
#Plot heatmap per group
#p + facet_wrap(~group, scales = "free_y")
p + facet_wrap(~group, scales = "free_y")
col.order <- hc$order
#Define groups from a cut-off k
group <- cutree(hc, k = 3)
df_group <- as.data.frame(group)
df_group <- as.data.frame(group)
df_group$Cell <- rownames(df_group)
dat_new <- dat[, col.order]
#Add the Time data back to the dataframe
dat_new$Time <- df1$Time
#Convert to tidy format
df_tidy <- gather(dat_new, Cell, Ratio, -Time)
#Add group number
df_tidy <- df_tidy %>% left_join(df_group, by="Cell")
#Use the column order from the dataframe for plotting
df_tidy$Cell <- factor(df_tidy$Cell, levels = df_tidy$Cell)
#Define the plot
p <- ggplot(df_tidy, aes(x=Time, y=Cell)) + geom_tile(aes(fill=Ratio)) +  scale_fill_gradient(low="darkblue", high="yellow")
#Basic format
p <- p + theme_light(base_size = 16)
#Remove gridlines
p <- p + theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
#Remove lines for axis
p <- p+ theme(panel.border = element_blank(),
axis.ticks = element_line(colour = "grey20"))
#Plot the heatmap
p
#Plot heatmap per group
#p + facet_wrap(~group, scales = "free_y")
col.order <- hc$order
group <- cutree(hc, k = 3)
df_group <- as.data.frame(group)
df_group <- as.data.frame(group)
df_group$Cell <- rownames(df_group)
#Reorder the dataframe dat according to the column order determined by clustering
dat_new <- dat[, col.order]
#Add the Time data back to the dataframe
dat_new$Time <- df1$Time
df1 <- read.csv("Fig3_Rac_S1P_30.csv")
#Get all the columns with data (without time axis)
dat <- df1[,2:31]
#Transpose dataframe; each row is a cell
tdat <- t(dat)
#Calculate the distance matrix
dst <- dist(tdat)
#Show distance matrix
dst_matrix <- as.matrix(dst)
#image(1:ncol(dst_matrix), 1:ncol(dst_matrix), dst_matrix, axes = FALSE, xlab="", ylab="")
#Perform cluster analysis on the data
hc <- hclust(dst, method="ward.D2")
#Uncomment to plot the dendogram
#plot(as.dendrogram(hc),horiz=T)
#determine column order that came out of cluster analysis (http://swarchal.github.io/pages/2015/11/25/heatmap-ggplot/)
col.order <- hc$order
#Define groups from a cut-off k
group <- cutree(hc, k = 3)
df_group <- as.data.frame(group)
df_group <- as.data.frame(group)
df_group$Cell <- rownames(df_group)
#Reorder the dataframe dat according to the column order determined by clustering
dat_new <- dat[, col.order]
#Add the Time data back to the dataframe
dat_new$Time <- df1$Time
#Convert to tidy format
df_tidy <- gather(dat_new, Cell, Ratio, -Time)
#Add group number
df_tidy <- df_tidy %>% left_join(df_group, by="Cell")
#Use the column order from the dataframe for plotting
df_tidy$Cell <- factor(df_tidy$Cell, levels = df_tidy$Cell)
#Define the plot
p <- ggplot(df_tidy, aes(x=Time, y=Cell)) + geom_tile(aes(fill=Ratio)) +  scale_fill_gradient(low="darkblue", high="yellow")
#Basic format
p <- p + theme_light(base_size = 16)
#Remove gridlines
p <- p + theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
#Remove lines for axis
p <- p+ theme(panel.border = element_blank(),
axis.ticks = element_line(colour = "grey20"))
#Plot the heatmap
p
#Plot heatmap per group
#p + facet_wrap(~group, scales = "free_y")
p + facet_wrap(~group, scales = "free_y")
dst_matrix
sort(dst_matrix)
?dist
require("ggplot2")
require("tidyr")
require("dplyr")
require("magrittr")
df1 <- read.csv("Fig3_Rac_S1P_30.csv")
#Get all the columns with data (without time axis)
dat <- df1[,2:31]
#Transpose dataframe; each row is a cell
tdat <- t(dat)
#Calculate the distance matrix
dst <- dist(tdat, method = "euclidean")
#Show distance matrix
dst_matrix <- as.matrix(dst)
#image(1:ncol(dst_matrix), 1:ncol(dst_matrix), dst_matrix, axes = FALSE, xlab="", ylab="")
#Perform cluster analysis on the data
hc <- hclust(dst, method="ward.D2")
#Uncomment to plot the dendogram
#plot(as.dendrogram(hc),horiz=T)
#determine column order that came out of cluster analysis (http://swarchal.github.io/pages/2015/11/25/heatmap-ggplot/)
col.order <- hc$order
#Define groups from a cut-off k
group <- cutree(hc, k = 3)
df_group <- as.data.frame(group)
df_group <- as.data.frame(group)
df_group$Cell <- rownames(df_group)
#Reorder the dataframe dat according to the column order determined by clustering
dat_new <- dat[, col.order]
#Add the Time data back to the dataframe
dat_new$Time <- df1$Time
#Convert to tidy format
df_tidy <- gather(dat_new, Cell, Ratio, -Time)
#Add group number
df_tidy <- df_tidy %>% left_join(df_group, by="Cell")
#Use the column order from the dataframe for plotting
df_tidy$Cell <- factor(df_tidy$Cell, levels = df_tidy$Cell)
#Define the plot
p <- ggplot(df_tidy, aes(x=Time, y=Cell)) + geom_tile(aes(fill=Ratio)) +  scale_fill_gradient(low="darkblue", high="yellow")
#Basic format
p <- p + theme_light(base_size = 16)
#Remove gridlines
p <- p + theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
#Remove lines for axis
p <- p+ theme(panel.border = element_blank(),
axis.ticks = element_line(colour = "grey20"))
#Plot the heatmap
p
#Plot heatmap per group
#p + facet_wrap(~group, scales = "free_y")
#Reorder the dataframe dat according to the column order determined by clustering
dat_new <- dat[, col.order]
runApp('~/surfdrive/Shiny-project/PlotTwist')
library("dtw", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
dst <- dist(tdat, method = "DTW")
dst_matrix <- as.matrix(dst)
image(1:ncol(dst_matrix), 1:ncol(dst_matrix), dst_matrix, axes = FALSE, xlab="", ylab="")
hc <- hclust(dst, method="ward.D2")
#determine column order that came out of cluster analysis (http://swarchal.github.io/pages/2015/11/25/heatmap-ggplot/)
col.order <- hc$order
#Define groups from a cut-off k
group <- cutree(hc, k = 3)
df_group <- as.data.frame(group)
df_group <- as.data.frame(group)
df_group$Cell <- rownames(df_group)
#Reorder the dataframe dat according to the column order determined by clustering
dat_new <- dat[, col.order]
#Add the Time data back to the dataframe
dat_new$Time <- df1$Time
#Convert to tidy format
df_tidy <- gather(dat_new, Cell, Ratio, -Time)
#Add group number
df_tidy <- df_tidy %>% left_join(df_group, by="Cell")
#Use the column order from the dataframe for plotting
df_tidy$Cell <- factor(df_tidy$Cell, levels = df_tidy$Cell)
#Define the plot
p <- ggplot(df_tidy, aes(x=Time, y=Cell)) + geom_tile(aes(fill=Ratio)) +  scale_fill_gradient(low="darkblue", high="yellow")
#Basic format
p <- p + theme_light(base_size = 16)
#Remove gridlines
p <- p + theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
#Remove lines for axis
p <- p+ theme(panel.border = element_blank(),
axis.ticks = element_line(colour = "grey20"))
#Plot the heatmap
p
#Plot heatmap per group
#p + facet_wrap(~group, scales = "free_y")
p + facet_wrap(~group, scales = "free_y")
?dist
runApp('~/surfdrive/Shiny-project/PlotTwist')
runApp('~/surfdrive/Shiny-project/PlotTwist')
runApp('~/surfdrive/Shiny-project/PlotTwist')
runApp('~/surfdrive/Shiny-project/PlotTwist')
runApp('~/surfdrive/Shiny-project/PlotTwist')
runApp('~/surfdrive/Shiny-project/PlotTwist')
ggplot(mpg, aes(fl)) + geom_bar()
head(mpg)
ggplot(mpg, aes(fl, fill = drv))+geom_bar()
ggplot(mpg, aes(fl, fill = drv))+geom_bar(position="fill")
runApp('~/surfdrive/Shiny-project/PlotTwist')
ggplot(mpg, aes(fl)) + geom_bar()
runApp('~/surfdrive/Shiny-project/PlotTwist')
runApp('~/surfdrive/Shiny-project/PlotTwist')
